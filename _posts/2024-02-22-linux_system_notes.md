---
layout: post
categories: blog
---

基于linux内核

### 进程调度

#### 完全公平调度器 CFS（Completely Fair Scheduler）

基本策略：

1.所有的**可运行进程**都按时间（等待时间）在一个**红黑树**中排序。

2.就绪队列还装备了虚拟时钟，该时钟的时间流逝速度慢于实际的时钟。

其他考量：

3.进程还要考虑优先级的问题（主要会在实时调度策略中体现）。

4.进程切换带来的上下文开销需要考虑。

#### 具体的策略

1. **调度器**：
   - Linux使用完全可抢占的多级反馈队列调度器（CFS）来管理进程调度。
   - CFS以公平的方式为每个进程分配CPU时间，尽量避免饥饿现象。
2. **调度策略**：
   - Linux支持多种调度策略，包括先进先出（FIFO）、短作业优先（SJF）、最短剩余时间优先（SRTF）、时间片轮转等。
   - 默认情况下，Linux使用CFS调度策略来实现公平调度。
3. **实时调度**：
   - Linux也支持实时调度策略，包括实时先进先出（RT-FIFO）和实时轮转（RT-RR）。
   - 实时调度器会优先考虑实时任务，以确保它们按时完成任务。



### 内存管理

(1) UMA计算机（一致内存访问，uniform memory access）多个cpu享用一块内存
(2) NUMA计算机（非一致内存访问，non-uniform memory access）多个cpu享用各自划分的内存

#### 伙伴系统

负责物理页帧的管理，主要用途是减少碎片或者是及时合并碎片，保证碎片尽量的少。

在伙伴系统中，**物理内存被划分为固定大小的块**，这些**块的大小是2的幂次方**。当程序请求内存时，内核会分配与请求大小最接近的2的幂次方大小的内存块。

伙伴系统围绕由多页组成的连续内存块的拆分和再合并展开。在连续内存区变为空闲时，内核会
自动注意到这一点，并在相应的分配请求出现时使用它。由于该机制在系统长时间运行后，无法以令
人满意的方式防止物理内存碎片发生，因此新近的内核版本引入了反碎片技术。它一方面允许按页的
可移动性将其分组，另一方面增加了一个新的虚拟内存域。二者的实质都在于降低在大块内存中间分
配内存的几率，以**避免碎片**出现。

#### slab分配器

处理小块内存的分配，并提供了用户层 malloc 函数族的内核等价物。

slab分配器在伙伴系统之上实现。它不仅允许分配任意用途的小块内存，还可用于对经常使用的
数据结构创建特定的缓存。

通过维护三个链表来管理内存：全局链表、活动链表和空闲链表。

- **全局链表（slabs）**：全局链表存储了所有已分配的内存页，每个页都被划分为若干个相同大小的内存块。这些内存块中的每一个都用来存储同一种类型的内核对象。
- **活动链表（partial）**：活动链表包含了部分已经被分配出去但尚未被填满的内存块。当有新的内存请求时，内核会首先检查这个链表，如果有符合大小要求的内存块，则从中分配内存。
- **空闲链表（free）**：空闲链表包含了完全空闲的内存块。当内核对象被释放时，内核会将其对应的内存块添加到空闲链表中，以便后续再次分配使用。

#### 物理内存管理：

- **页面分配**：Linux使用伙伴系统（Buddy System）来管理物理内存的分配和释放。物理内存被划分为固定大小的块，并按照2的幂次方进行组织。这种分配策略有助于减少内存碎片化。
- **页面回收**：Linux通过页面回收机制来回收不再使用的内存页面，包括LRU（最近最少使用）页面替换策略和页面交换（swap）机制。





### 文件管理

#### 虚拟文件系统（Virtual File System）

**特点**：

1. **抽象接口**：VFS提供了一组抽象的文件系统接口，包括打开、关闭、读取、写入、重命名等操作。这些接口对于所有支持的文件系统都是统一的，使得用户程序可以不加修改地在不同的文件系统之间进行切换。
2. **文件系统注册**：VFS允许内核中加载和注册不同类型的文件系统。每个文件系统都必须实现VFS定义的标准接口，以便与其他文件系统兼容。
3. **挂载和卸载**：VFS允许将不同的文件系统挂载到系统的文件树中，使得用户可以访问不同的存储介质，如硬盘、光盘、网络存储等。
4. **虚拟路径解析**：VFS提供了虚拟路径解析功能，它将用户程序的文件操作映射到具体的文件系统上。这样，用户程序可以使用相同的路径格式来访问不同类型的文件系统。

**组成部分**：

1. **超级块（Superblock）**：超级块是每个文件系统的元数据结构，它包含了文件系统的属性信息，如文件系统类型、块大小、inode大小等。在VFS中，每个挂载的文件系统都对应一个超级块。
2. **索引节点（Inode）**：索引节点是文件系统中文件或目录的元数据结构，它包含了文件或目录的属性信息，如文件大小、访问权限、链接计数等。在VFS中，每个文件或目录都对应一个索引节点。
3. **文件描述符表（File Descriptor Table）**：文件描述符表是进程内部的数据结构，用于跟踪每个进程打开的文件。在VFS中，每个文件描述符对应一个打开的文件，并包含了文件在文件系统中的位置、访问模式等信息。
4. **虚拟文件系统层（VFS Layer）**：虚拟文件系统层是VFS的核心组件，它提供了一组抽象的文件系统接口，如`open()`、`read()`、`write()`等。用户程序通过调用这些接口来进行文件操作，而不需要关心底层文件系统的具体实现。

通过VFS，Linux内核实现了文件系统的抽象和标准化，使得用户程序可以方便地访问不同类型的文件系统，而不受底层文件系统的影响。 VFS在Linux系统中发挥着至关重要的作用，为用户空间提供了一个统一、一致的文件系统接口。



#### ext2（基于磁盘的文件系统）

**主要策略**：ext2文件系统是一种基于块的文件系统，它将硬盘划分为若干块，每个块的长度都相同，按块管理元数据和文件内容。并且与其他设备传递数据也是通过块为单位来传递而不是单个字节

**大文件处理**：ext2通过两次间接使用inode来处理大文件，对于更大的文件linux则使用了其他的代码来进行处理（而不是通过三次间接inode来处理）

对于其block group

**超级块**（1个块）：超级块是用于存储文件系统自身元数据的核心结构。其中的信息包括空闲与已使用块的数目、
块长度、当前文件系统状态（在启动时用于检测前一次崩溃）、各种时间戳（例如，上一次装载文件系统的时间以及上一次写入操作的时间）。它还包括一个表示文件系统类型的魔数，这样 mount 例程能够确认文件系统的类型是否正确。
内核只使用第一个块组的超级块读取文件系统的元信息，即使在几个超级块中都有超级块，也是如此。
**组描述符**（k个块）：组描述符包含的信息反映了文件系统中各个块组的状态，例如，块组中空闲块和inode的数目。
每个块组都包含了文件系统中所有块组的组描述符信息。
**数据位图和innode位图**（均1个块）： 数据块位图和inode位图用于保存长的比特位串。这些结构中的每个比特位都对应于一个数据
块或inode，用于表示对应的数据块或inode是空闲的，还是被使用中。
**innode表**（n个块）： inode表包含了块组中所有的inode， inode用于保存文件系统中与各个文件和目录相关的所有元数据。
**数据块**（m个块）： 顾名思义，数据块部分包含了文件系统中的文件的有用数据。



#### ext3（基于磁盘的文件系统）

**主要策略**：相对于ext2，ext3主要对文件系统元数据的每个操作都视为事务，并且对其进行记录（日志）