---
layout: post
categories: blog
---
## 一.将十进制数转换成二进制
举例
### （1）0.6转换成二进制
在小数点前的转换（取余数，然后舍去余数）
第一步：0 / 2 = 0，取0【除数为0，结束】
在小数点后的转换（取小数点前的数，然后舍去）
第一步：0.6 x 2 = 1.2，取1，
第二步：0.2 x 2 = 0.4，取0
第三步：0.4 x 2 = 0.8，取0
第四步：0.8 x 2 = 1.6，取1
第五步：0.6 x 2 = 1.2，取1，回到第一步
......【循环，没有结束】
故0.6的二进制为0.100110011001......
### （2）173.8125转换成二进制
在小数点前的转换（取余数，然后舍去余数）
第一步：173 / 2 = 86……1，取1
第二步：086 / 2 = 43……0，取0
第四步：043 / 2 = 21……1，取1 
第五步：021 / 2 = 10……1，取1 
第六步：010 / 2 = 05……0，取0 
第七步：005 / 2 = 02……1，取1
第八步：002 / 2 = 01……0，取0 
第九步：001 / 2 = 00……1，取1【再往下做就是零除以二了，故除数为0的时候结束】从下往上取为10101101
在小数点后的转换（若有1.0则取小数点前的数，然后舍去）
第一步：0.8125 x 2 = 1.6250，取1，
第二步：0.6250 x 2 = 1.2500，取1
第三步：1.2500 x 2 = 0.0500，取0
第四步：0.0500 x 2 = 1.0000，取1【再往下做就是零乘以二了，故结果为1的时候结束】从上往下取为1101
故173.8125的二进制位10101101.1101

## 二、将小数转换成科学计数法
### （1）0.6
0.6二进制为0.100110011001......，
科学计数法为1.00110011001...... x 10^-1^
【严谨一点应将10^-1^改为2^-1^】
### （2）173.8125
173.8125二进制为10101101.1101，
科学计数法为1.01011011101 x 10^+7^
【严谨一点应将10^+7^改为2^+7^】

## 三、存储在内存中（以32位float为例）
注意：这里所填的指数位的值并不是前面计算出来的指数的数字，而是等于实际指数数字加上一个指数偏移值，对于32位单精度浮点数来说，偏移值为127(2^(8-1)^-1，8为指数位的长度)，64位双精度浮点数为1023(2^(11-1)^-1，11为指数位的长度)，，所以指数位的值为127 + 6 = 133 ,二进制表示为10000101
### （1）0.6
符号位为0，表示为正数，1位符号位记0
阶码(指数)为-1，-1+127 = 126，8位指数位记~~1111110~~ ，这里写错了应该为01111110
1.00110011001……记在23位尾数位(从小数点后开始)记(3+4x5)
001 1001 1001 1001 1001 1001
故在内存中存储的二进制代码为(1+8+23)
0 ~~1111110~~  00110011001100110011001（之前写的时候少了一位居然没发现）应改为
~~0 01111110  00110011001100110011001~~ （在实际计算机中因为有舍入误差，向偶取舍这个概念，故我在实际测试的时候发现并不是这样）
0 01111110 00110011001100110011010（末尾不太一样，具体原因可以搜索IEEE标准的舍入误差这个概念）

```bash
0.6
测试float数为:0.6f
二进制表示为:0, 01111110, 00110011001100110011010
```

### （2）173.8125
符号位为0，表示为正数，1位符号位记0
阶码(指数)为7，7+127 = 134，8位指数位记10000110
1.01011011101记在23位尾数位(从小数点后开始)记(11有效+12个0)
01011011101 000000000000
故在内存中存储的二进制代码为(1+8+23)
0 10000110 01011011101000000000000